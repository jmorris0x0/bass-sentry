Sub-Bass: 20 Hz - 60 Hz

This range includes the lowest frequencies that humans can perceive. Sounds in this range are often felt as vibrations rather than clearly heard.

Bass: 60 Hz - 250 Hz

This range covers the fundamental frequencies of many musical instruments and encompasses much of the "boominess" people associate with bass.


from(bucket: "mybucket")
  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)
  |> filter(fn: (r) => r["_measurement"] == "dBFS")
  |> aggregateWindow(every: v.windowPeriod, fn: mean, createEmpty: false)
  |> yield(name: "mean")


Use this to create a new password for greylog:

echo -n yourpassword | shasum -a 256


"""
Data Structure:
{
    "data_type": string,  # Either "audio_chunk" or "scalar"
    "timestamp": int, # Epoch
    "time_precision": string, # Either ns, us, ms, s
    "data": list or float,  # list for "audio_chunk" and float for "scalar"
    "metadata": {
        "sample_rate": int,  # Required if "audio_chunk"
        "bit_depth": int,  # Required if "audio_chunk"
        "filter_low": int,  # Optional
        "filter_high": int,  # Optional
        "units": str  # Required if "scalar"
        "tags": list # Optional
        "location": str # Required

    }
}
"""


Acceptable frequencies for grid decimation:

```
from math import gcd, sqrt

def valid_frequencies():
    ns_in_second = 10**9
    valid_freqs = set()
    for i in range(1, int(sqrt(ns_in_second)) + 1):
        if ns_in_second % i == 0:
            valid_freqs.add(i)
            valid_freqs.add(ns_in_second // i)
    valid_freqs = sorted(list(valid_freqs), reverse=True)
    return [ns_in_second / i for i in valid_freqs]

# Example usage:
valid_freqs = valid_frequencies()
print(valid_freqs)
```

1.0, 2.0, 4.0, 5.0, 8.0, 10.0, 16.0, 20.0, 25.0, 32.0, 40.0, 50.0, 64.0, 80.0, 100.0, 125.0, 128.0, 160.0, 200.0, 250.0, 256.0, 320.0, 400.0, 500.0, 512.0, 625.0, 640.0, 800.0, 1000.0, 1250.0, 1280.0, 1600.0, 2000.0, 2500.0, 2560.0, 3125.0, 3200.0, 4000.0, 5000.0, 6250.0, 6400.0, 8000.0, 10000.0, 12500.0, 12800.0, 15625.0, 16000.0, 20000.0, 25000.0, 31250.0, 32000.0, 40000.0...



TODO:
Sometimes the remote node just goes no route to host and won't fix until reboot.
Support mutiple fields?

zeroconf ntp:
https://chat.openai.com/share/823fe7f0-0488-492a-9baa-5d95731e490c

Fix it so that the location comes from the config file and finds its way all to the end.

Make room to send actual audio data to InfluxDB. I'm currently monopolizing audio-chunks for CC.

Add Cross correlation tag to CC output, maybe?

Change units to dBZ

Switch all timeseries from float to int.
Use numpy.to_bytes to serialize rather than a list.
Just start passing 2D ts rather than 1D.

Weighting:
https://github.com/python-acoustics/python-acoustics/blob/master/acoustics/weighting.py



16 bit full scale is 96.
I'm adjsuting by 94 to convert to dBFS.

The dBSPL is 40 when it's quiet. That means the actual dBFS is 40 - 94 = -54

That means we only have 54dB of headroom at our current level of gain.

That's 54 + 40 = 94 dB

We will hit 115 at the party.

120 - 94 = 26

That means we are 26db too high. I think I need to lower the gain on my audio interface by 20dB. I don't have a reference source so does that mean I just look at the dB of a constant noise and lower until the number is 26 less?

Yes. Then increase your reference number by 26 to 120.

Interesting. So the procedure is to consider the loudest dBSPL that you will want to measure without clipping. Set that as your REFERENCE. This is what 0 dbFS will correspond to. Next, calibrate your gain to some source. Probably with a iwatch or a iPhone app.



Dashboards:

DJ:
Needs to be simple.

dbSPL full in the dancecave - 15 min
Subbass in the dancecave
Line that's too high in the dance cave for dbSPL
Meters for dBSPL ad subbass



Subbass in 32 with line showing audible


I want one just for the DJ. We can adjust the numbers as the night progresses
